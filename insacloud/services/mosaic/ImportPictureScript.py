import ImageFormatter
from PIL import Image
import math
import random

# Algo var
imageDim = 512 # all images will have imageDim*imageDim pixels
mosaicDim = 64 # mosaic will have mosaicDim*mosaicDim images
nbTilesPerDim = 4 # mosaic will have nbTilesPerDim*nbTilesPerDim tiles
tileDim = int(mosaicDim/nbTilesPerDim) # tile will have tileDim*tileDim images
mosaic = Image.new('L', (imageDim*nbTilesPerDim, imageDim*nbTilesPerDim)) # mosaic is generated by merging tiles

# create mosaicDim*mosaicDim matrix
mosaicMatrix = [[0 for i in range(mosaicDim)] for i in range(mosaicDim)]

# Open Image :
imFormat =ImageFormatter.ImageFormatter("troll512x512.png")
# ?
color = imFormat.process_image()
# ?
image = imFormat.get_image()
# ?
pixel = image.load()

# TODO - Build this dictionnary
hueMap = {"1":[image]}

def find_closest_available_hue(targetHue, hueMap):
    if(str(targetHue) in hueMap):
        return hueMap[str(targetHue)][random.randint(0,len(hueMap[str(targetHue)])-1)]
    min=256
    k = None
    for key in hueMap:
        hue = int(key)
        if(abs(hue - targetHue) < min):
            min = abs(hue - targetHue)
            k = key
    return hueMap[k][random.randint(0,len(hueMap[k])-1)]

# feed mosaicMatrix with mosaicDim*mosaicDim images
for x in range(mosaicDim):
    for y in range(mosaicDim):
        hue = pixel[x,y]
        find_closest_available_hue(hue, hueMap)
        mosaicMatrix[x][y] = image

# generate tiles and mosaic
# might be functionalized (huge nb of vars+)
for i in range(0, nbTilesPerDim, 1): # 
    for j in range(0, nbTilesPerDim, 1):
        tile = Image.new('L', (imageDim*tileDim,imageDim*tileDim))
        for k in range(i*tileDim, (i+1)*tileDim, 1):
            for l in range(j*tileDim, (j+1)*tileDim, 1):
                # build tile with merging images
                tile.paste(mosaicMatrix[k][l], ((k%tileDim)*imageDim, (l%tileDim)*imageDim,((k%tileDim)+1)*imageDim, ((l%tileDim)+1)*imageDim))
        # resize tile image
        tile = tile.resize((imageDim,imageDim), Image.ANTIALIAS)
        # build mosaic with merging tiles
        mosaic.paste(tile, ((i%nbTilesPerDim)*imageDim, (j%nbTilesPerDim)*imageDim,((i%nbTilesPerDim)+1)*imageDim, ((j%nbTilesPerDim)+1)*imageDim))
        # export mosaic image
        tile.save("tile-"+str(i)+"-"+str(j)+".jpg", "JPEG")

# resize mosaic image
mosaic = mosaic.resize((imageDim,imageDim), Image.ANTIALIAS)
# export mosaic image
mosaic.save("mosaic.jpg", "JPEG")

########## LEGACY ##########

# import ImageFormatter
# from PIL import Image
# import math

# #databaseName = "events.db"
# # event1 = "Concert_Mika_2012"
# #
# # dbMan = DatabaseManager.SqliteManager(databaseName)
# #
# # dbMan.create_event(event1)
# #
# # dbMan.insert_picture(event1, ["80", "Mika1.jpg"])

# # Algo var
# t = 3
# z = 4

# matrixA = [[0 for i in range(64)] for i in range(64)]

# # Open Image :
# imFormat =ImageFormatter.ImageFormatter("troll64x64.jpg")
# color = imFormat.process_image()
# image = imFormat.get_image()
# #image.show()
# pixel = image.load()

# # Sur une suggestion de Lele :
# caca = Image.new('L', (64*64, 64*64))

# for x in range(image.size[0]):
#     for y in range(image.size[1]):
#         #Access pixel
#         #print pixel[x,y]
#         matrixA[x][y] = image


# for k in range(t, 0, -1):
#     print k
#     dim1 = (len(matrixA)/z)*64
#     matrixB = [[Image.new('L', (dim1,dim1)) for i in range(4)] for i in range(4)]
#     dim2 = int(64*math.pow(z,k))
#     print len(matrixA)
#     for x in range(0, len(matrixA)):
#         for y in range(0, len(matrixA)):
#             #paste(matrixA[x][y], (x*64, y*64,(x+1)*64, (y+1)*64))
#             i = int(y/len(matrixA)/z)
#             j = int(x/len(matrixA)/z)
#             #print str(x)+"-"+str(y)+"|"+str(j)+"-"+str(i)
#             matrixB[j][i].paste(image, (x*64, y*64,(x+1)*64, (y+1)*64))

#     matrixA = [[0 for i in range(4)] for i in range(4)]

#     for x in range(len(matrixB)):
#         for y in range(len(matrixB)):
#             matrixB[x][y] = matrixB[x][y].resize((64,64), Image.ANTIALIAS)
#             # Sauvegarde matrixB comme mosaic
#             matrixA[x][y] = matrixB[x][y]

#     matrixA[0][0].show()



# # im.show()